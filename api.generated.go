// Package codaapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package codaapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for AccessType.
const (
	AccessTypeComment AccessType = "comment"

	AccessTypeNone AccessType = "none"

	AccessTypeReadonly AccessType = "readonly"

	AccessTypeWrite AccessType = "write"
)

// Defines values for ApiLinkType.
const (
	ApiLinkTypeApiLink ApiLinkType = "apiLink"
)

// Defines values for ColumnType.
const (
	ColumnTypeColumn ColumnType = "column"
)

// Defines values for ColumnDetailType.
const (
	ColumnDetailTypeColumn ColumnDetailType = "column"
)

// Defines values for ColumnFormatType.
const (
	ColumnFormatTypeAttachments ColumnFormatType = "attachments"

	ColumnFormatTypeButton ColumnFormatType = "button"

	ColumnFormatTypeCanvas ColumnFormatType = "canvas"

	ColumnFormatTypeCheckbox ColumnFormatType = "checkbox"

	ColumnFormatTypeCurrency ColumnFormatType = "currency"

	ColumnFormatTypeDate ColumnFormatType = "date"

	ColumnFormatTypeDateTime ColumnFormatType = "dateTime"

	ColumnFormatTypeDuration ColumnFormatType = "duration"

	ColumnFormatTypeEmail ColumnFormatType = "email"

	ColumnFormatTypeImage ColumnFormatType = "image"

	ColumnFormatTypeLookup ColumnFormatType = "lookup"

	ColumnFormatTypeNumber ColumnFormatType = "number"

	ColumnFormatTypeOther ColumnFormatType = "other"

	ColumnFormatTypePackObject ColumnFormatType = "packObject"

	ColumnFormatTypePercent ColumnFormatType = "percent"

	ColumnFormatTypePerson ColumnFormatType = "person"

	ColumnFormatTypeReaction ColumnFormatType = "reaction"

	ColumnFormatTypeScale ColumnFormatType = "scale"

	ColumnFormatTypeSelect ColumnFormatType = "select"

	ColumnFormatTypeSlider ColumnFormatType = "slider"

	ColumnFormatTypeText ColumnFormatType = "text"

	ColumnFormatTypeTime ColumnFormatType = "time"
)

// Defines values for ColumnReferenceType.
const (
	ColumnReferenceTypeColumn ColumnReferenceType = "column"
)

// Defines values for ControlType.
const (
	ControlTypeControl ControlType = "control"
)

// Defines values for ControlReferenceType.
const (
	ControlReferenceTypeControl ControlReferenceType = "control"
)

// Defines values for CurrencyFormatType.
const (
	CurrencyFormatTypeAccounting CurrencyFormatType = "accounting"

	CurrencyFormatTypeCurrency CurrencyFormatType = "currency"

	CurrencyFormatTypeFinancial CurrencyFormatType = "financial"
)

// Defines values for DocType.
const (
	DocTypeDoc DocType = "doc"
)

// Defines values for DocAnalyticsScale.
const (
	DocAnalyticsScaleCumulative DocAnalyticsScale = "cumulative"

	DocAnalyticsScaleDaily DocAnalyticsScale = "daily"
)

// Defines values for DocPublishMode.
const (
	DocPublishModeEdit DocPublishMode = "edit"

	DocPublishModePlay DocPublishMode = "play"

	DocPublishModeView DocPublishMode = "view"
)

// Defines values for DocReferenceType.
const (
	DocReferenceTypeDoc DocReferenceType = "doc"
)

// Defines values for DocumentCreationResultType.
const (
	DocumentCreationResultTypeDoc DocumentCreationResultType = "doc"
)

// Defines values for DurationUnit.
const (
	DurationUnitDays DurationUnit = "days"

	DurationUnitHours DurationUnit = "hours"

	DurationUnitMinutes DurationUnit = "minutes"

	DurationUnitSeconds DurationUnit = "seconds"
)

// Defines values for EmailDisplayType.
const (
	EmailDisplayTypeEmailOnly EmailDisplayType = "emailOnly"

	EmailDisplayTypeIconAndEmail EmailDisplayType = "iconAndEmail"

	EmailDisplayTypeIconOnly EmailDisplayType = "iconOnly"
)

// Defines values for FolderReferenceType.
const (
	FolderReferenceTypeFolder FolderReferenceType = "folder"
)

// Defines values for FormulaType.
const (
	FormulaTypeFormula FormulaType = "formula"
)

// Defines values for FormulaReferenceType.
const (
	FormulaReferenceTypeFormula FormulaReferenceType = "formula"
)

// Defines values for IconSet.
const (
	IconSetBattery IconSet = "battery"

	IconSetBell IconSet = "bell"

	IconSetBug IconSet = "bug"

	IconSetCheckmark IconSet = "checkmark"

	IconSetChili IconSet = "chili"

	IconSetCircle IconSet = "circle"

	IconSetCloud IconSet = "cloud"

	IconSetCocktail IconSet = "cocktail"

	IconSetCoffee IconSet = "coffee"

	IconSetCurrency IconSet = "currency"

	IconSetDiamond IconSet = "diamond"

	IconSetFire IconSet = "fire"

	IconSetHeart IconSet = "heart"

	IconSetLightbulb IconSet = "lightbulb"

	IconSetLightning IconSet = "lightning"

	IconSetPerson IconSet = "person"

	IconSetSmiley IconSet = "smiley"

	IconSetStar IconSet = "star"

	IconSetSun IconSet = "sun"

	IconSetThumbsup IconSet = "thumbsup"
)

// Defines values for ImageStatus.
const (
	ImageStatusDeleted ImageStatus = "deleted"

	ImageStatusFailed ImageStatus = "failed"

	ImageStatusLive ImageStatus = "live"
)

// Defines values for Layout.
const (
	LayoutAreaChart Layout = "areaChart"

	LayoutBarChart Layout = "barChart"

	LayoutBubbleChart Layout = "bubbleChart"

	LayoutCalendar Layout = "calendar"

	LayoutCard Layout = "card"

	LayoutDefault Layout = "default"

	LayoutDetail Layout = "detail"

	LayoutForm Layout = "form"

	LayoutGanttChart Layout = "ganttChart"

	LayoutLineChart Layout = "lineChart"

	LayoutMasterDetail Layout = "masterDetail"

	LayoutPieChart Layout = "pieChart"

	LayoutScatterChart Layout = "scatterChart"

	LayoutSlide Layout = "slide"

	LayoutWordCloud Layout = "wordCloud"
)

// Defines values for LinkedDataType.
const (
	LinkedDataTypeImageObject LinkedDataType = "ImageObject"

	LinkedDataTypeMonetaryAmount LinkedDataType = "MonetaryAmount"

	LinkedDataTypePerson LinkedDataType = "Person"

	LinkedDataTypeStructuredValue LinkedDataType = "StructuredValue"

	LinkedDataTypeWebPage LinkedDataType = "WebPage"
)

// Defines values for PageType.
const (
	PageTypePage PageType = "page"
)

// Defines values for PageReferenceType.
const (
	PageReferenceTypePage PageReferenceType = "page"
)

// Defines values for PrincipalType.
const (
	PrincipalTypeAnyone PrincipalType = "anyone"

	PrincipalTypeDomain PrincipalType = "domain"

	PrincipalTypeEmail PrincipalType = "email"
)

// Defines values for RowType.
const (
	RowTypeRow RowType = "row"
)

// Defines values for RowDetailType.
const (
	RowDetailTypeRow RowDetailType = "row"
)

// Defines values for RowValueAdditionalType.
const (
	RowValueAdditionalTypeRow RowValueAdditionalType = "row"
)

// Defines values for RowsSortBy.
const (
	RowsSortByCreatedAt RowsSortBy = "createdAt"

	RowsSortByNatural RowsSortBy = "natural"

	RowsSortByUpdatedAt RowsSortBy = "updatedAt"
)

// Defines values for SortBy.
const (
	SortByName SortBy = "name"
)

// Defines values for SortDirection.
const (
	SortDirectionAscending SortDirection = "ascending"

	SortDirectionDescending SortDirection = "descending"
)

// Defines values for TableType.
const (
	TableTypeTable TableType = "table"
)

// Defines values for TableReferenceType.
const (
	TableReferenceTypeTable TableReferenceType = "table"
)

// Defines values for Type.
const (
	TypeAclMetadata Type = "aclMetadata"

	TypeAclPermissions Type = "aclPermissions"

	TypeApiLink Type = "apiLink"

	TypeColumn Type = "column"

	TypeControl Type = "control"

	TypeDoc Type = "doc"

	TypeDocAnalytics Type = "docAnalytics"

	TypeFolder Type = "folder"

	TypeFormula Type = "formula"

	TypeMutationStatus Type = "mutationStatus"

	TypePack Type = "pack"

	TypePackAclPermissions Type = "packAclPermissions"

	TypePackAsset Type = "packAsset"

	TypePackCategory Type = "packCategory"

	TypePackLog Type = "packLog"

	TypePackMaker Type = "packMaker"

	TypePackOauthConfig Type = "packOauthConfig"

	TypePackRelease Type = "packRelease"

	TypePackSourceCode Type = "packSourceCode"

	TypePackSystemConnection Type = "packSystemConnection"

	TypePackVersion Type = "packVersion"

	TypePage Type = "page"

	TypeRow Type = "row"

	TypeTable Type = "table"

	TypeUser Type = "user"

	TypeWorkspace Type = "workspace"
)

// Defines values for UserType.
const (
	UserTypeUser UserType = "user"
)

// Defines values for ValueFormat.
const (
	ValueFormatRich ValueFormat = "rich"

	ValueFormatSimple ValueFormat = "simple"

	ValueFormatSimpleWithArrays ValueFormat = "simpleWithArrays"
)

// Defines values for WorkspaceReferenceType.
const (
	WorkspaceReferenceTypeWorkspace WorkspaceReferenceType = "workspace"
)

// Defines values for WorkspaceUserRole.
const (
	WorkspaceUserRoleAdmin WorkspaceUserRole = "Admin"

	WorkspaceUserRoleDocMaker WorkspaceUserRole = "DocMaker"

	WorkspaceUserRoleEditor WorkspaceUserRole = "Editor"
)

// Type of access.
type AccessType string

// List of Permissions.
type Acl struct {
	// API link to these results
	Href         string       `json:"href"`
	Items        []Permission `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Doc level metadata associated with ACL.
type AclMetadata struct {
	// When true, the user of the api can copy the doc
	CanCopy bool `json:"canCopy"`

	// When true, the user of the api can share
	CanShare bool `json:"canShare"`

	// When true, the user of the api can share with the org
	CanShareWithOrg bool `json:"canShareWithOrg"`
}

// Payload for granting a new permission.
type AddPermissionRequest struct {
	// Type of access.
	Access AccessType `json:"access"`

	// Metadata about a principal.
	Principal Principal `json:"principal"`

	// When true suppresses email notification
	SuppressEmail *bool `json:"suppressEmail,omitempty"`
}

// The result of sharing a doc.
type AddPermissionResult map[string]interface{}

// AnyonePrincipal defines model for AnyonePrincipal.
type AnyonePrincipal struct {
	// Type of principal.
	Type PrincipalType `json:"type"`
}

// Info about a resolved link to an API resource.
type ApiLink struct {
	// Canonical browser-friendly link to the resolved resource.
	BrowserLink *string `json:"browserLink,omitempty"`

	// Self link to this query.
	Href string `json:"href"`

	// Reference to the resolved resource.
	Resource ApiLinkResolvedResource `json:"resource"`

	// The type of this resource.
	Type ApiLinkType `json:"type"`
}

// The type of this resource.
type ApiLinkType string

// Reference to the resolved resource.
type ApiLinkResolvedResource struct {
	// API link to the resolved resource that can be queried to get further information.
	Href string `json:"href"`

	// ID of the resolved resource.
	Id string `json:"id"`

	// Name of the resource.
	Name *string `json:"name,omitempty"`

	// A constant identifying the type of the resource.
	Type Type `json:"type"`
}

// ButtonColumnFormat defines model for ButtonColumnFormat.
type ButtonColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Action formula for the button.
	Action *string `json:"action,omitempty"`

	// DisableIf formula for the button.
	DisableIf *string `json:"disableIf,omitempty"`

	// Label formula for the button.
	Label *string `json:"label,omitempty"`
}

// An edit made to a particular cell in a row.
type CellEdit struct {
	// Column ID, URL, or name (fragile and discouraged) associated with this edit.
	Column string `json:"column"`

	// A Coda result or entity expressed as a primitive type, or array of primitive types.
	Value Value `json:"value"`
}

// All values that a row cell can contain.
type CellValue interface{}

// Parameters for changing a workspace user role.
type ChangeRole struct {
	// Email of the user.
	Email   string            `json:"email"`
	NewRole WorkspaceUserRole `json:"newRole"`
}

// The result of changing a user's workspace user role.
type ChangeRoleResult struct {
	// Timestamp for when the user's role last changed in this workspace.
	RoleChangedAt time.Time `json:"roleChangedAt"`
}

// Info about a column.
type Column struct {
	// Whether the column has a formula set on it.
	Calculated *bool `json:"calculated,omitempty"`

	// Default value formula for the column.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Whether the column is the display column.
	Display *bool `json:"display,omitempty"`

	// Format of a column.
	Format ColumnFormat `json:"format"`

	// Formula on the column.
	Formula *string `json:"formula,omitempty"`

	// API link to the column.
	Href string `json:"href"`

	// ID of the column.
	Id string `json:"id"`

	// Name of the column.
	Name string `json:"name"`

	// The type of this resource.
	Type ColumnType `json:"type"`
}

// The type of this resource.
type ColumnType string

// Info about a column.
type ColumnDetail struct {
	// Whether the column has a formula set on it.
	Calculated *bool `json:"calculated,omitempty"`

	// Default value formula for the column.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Whether the column is the display column.
	Display *bool `json:"display,omitempty"`

	// Format of a column.
	Format ColumnFormat `json:"format"`

	// Formula on the column.
	Formula *string `json:"formula,omitempty"`

	// API link to the column.
	Href string `json:"href"`

	// ID of the column.
	Id string `json:"id"`

	// Name of the column.
	Name string `json:"name"`

	// Reference to a table or view.
	Parent TableReference `json:"parent"`

	// The type of this resource.
	Type ColumnDetailType `json:"type"`
}

// The type of this resource.
type ColumnDetailType string

// Format of a column.
type ColumnFormat interface{}

// Format type of the column
type ColumnFormatType string

// List of columns.
type ColumnList struct {
	// API link to these results
	Href         *string  `json:"href,omitempty"`
	Items        []Column `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Reference to a column.
type ColumnReference struct {
	// API link to the column.
	Href string `json:"href"`

	// ID of the column.
	Id string `json:"id"`

	// The type of this resource.
	Type ColumnReferenceType `json:"type"`
}

// The type of this resource.
type ColumnReferenceType string

// Details about a control.
type Control struct {
	// Type of the control.
	ControlType ControlType `json:"controlType"`

	// API link to the control.
	Href string `json:"href"`

	// ID of the control.
	Id string `json:"id"`

	// Name of the control.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type ControlType `json:"type"`

	// A Coda result or entity expressed as a primitive type, or array of primitive types.
	Value Value `json:"value"`
}

// The type of this resource.
type ControlType string

// List of controls.
type ControlList struct {
	// API link to these results
	Href         *string            `json:"href,omitempty"`
	Items        []ControlReference `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Reference to a control.
type ControlReference struct {
	// API link to the control.
	Href string `json:"href"`

	// ID of the control.
	Id string `json:"id"`

	// Name of the control.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type ControlReferenceType `json:"type"`
}

// The type of this resource.
type ControlReferenceType string

// A numeric monetary amount as a string or number.
type CurrencyAmount interface{}

// CurrencyColumnFormat defines model for CurrencyColumnFormat.
type CurrencyColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The currency symbol
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// How the numeric value should be formatted (with or without symbol, negative numbers in parens).
	Format *CurrencyFormatType `json:"format,omitempty"`

	// The decimal precision.
	Precision *int `json:"precision,omitempty"`
}

// How the numeric value should be formatted (with or without symbol, negative numbers in parens).
type CurrencyFormatType string

// CurrencyValue defines model for CurrencyValue.
type CurrencyValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// A numeric monetary amount as a string or number.
	Amount CurrencyAmount `json:"amount"`

	// The 3-letter currency code.
	Currency string `json:"currency"`
}

// DateColumnFormat defines model for DateColumnFormat.
type DateColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	Format *string `json:"format,omitempty"`
}

// DateTimeColumnFormat defines model for DateTimeColumnFormat.
type DateTimeColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	DateFormat *string `json:"dateFormat,omitempty"`

	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	TimeFormat *string `json:"timeFormat,omitempty"`
}

// The result of deleting a permission.
type DeletePermissionResult map[string]interface{}

// Metadata about a Coda doc.
type Doc struct {
	// Browser-friendly link to the Coda doc.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the doc was created.
	CreatedAt time.Time `json:"createdAt"`

	// The number of components within a Coda doc.
	DocSize *DocSize `json:"docSize,omitempty"`

	// Reference to a Coda folder.
	Folder FolderReference `json:"folder"`

	// ID of the Coda folder containing this doc.
	FolderId string `json:"folderId"`

	// API link to the Coda doc.
	Href string `json:"href"`

	// Info about the icon.
	Icon *Icon `json:"icon,omitempty"`

	// ID of the Coda doc.
	Id string `json:"id"`

	// Name of the doc.
	Name string `json:"name"`

	// Email address of the doc owner.
	Owner openapi_types.Email `json:"owner"`

	// Name of the doc owner.
	OwnerName string `json:"ownerName"`

	// Information about the publishing state of the document.
	Published *DocPublished `json:"published,omitempty"`
	SourceDoc *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/DocReference)
		DocReference `yaml:",inline"`
	} `json:"sourceDoc,omitempty"`

	// The type of this resource.
	Type DocType `json:"type"`

	// Timestamp for when the doc was last modified.
	UpdatedAt time.Time `json:"updatedAt"`

	// Reference to a Coda workspace.
	Workspace WorkspaceReference `json:"workspace"`

	// ID of the Coda workspace containing this doc.
	WorkspaceId string `json:"workspaceId"`
}

// The type of this resource.
type DocType string

// List of analytics for Coda docs over a date range.
type DocAnalyticsCollection struct {
	Items        []DocAnalyticsItem `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Analytics data for a Coda doc.
type DocAnalyticsItem struct {
	// Number of times the doc was copied.
	Copies int `json:"copies"`

	// Date of the analytics data.
	Date openapi_types.Date `json:"date"`
	Doc  struct {
		// Embedded struct due to allOf(#/components/schemas/DocReference)
		DocReference `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		// Title of the doc.
		Title string `json:"title"`
	} `json:"doc"`

	// Number of times the doc was liked.
	Likes int `json:"likes"`

	// Number of unique visitors to this doc from a desktop device.
	SessionsDesktop int `json:"sessionsDesktop"`

	// Number of unique visitors to this doc from a mobile device.
	SessionsMobile int `json:"sessionsMobile"`

	// Number of unique visitors to this doc from an unknown device type.
	SessionsOther int `json:"sessionsOther"`

	// Number of times the doc was viewed.
	Views int `json:"views"`
}

// Quantization period over which to view analytics.
type DocAnalyticsScale string

// The category applied to a doc.
type DocCategory struct {
	// Name of the category.
	Name string `json:"name"`
}

// A list of categories that can be applied to a doc.
type DocCategoryList struct {
	// Categories for the doc.
	Items []DocCategory `json:"items"`
}

// Payload for creating a new doc.
type DocCreate struct {
	// The ID of the folder within which to create this doc. Defaults to your "My docs" folder in the oldest workspace you joined; this is subject to change. You can get this ID by opening the folder in the docs list on your computer and grabbing the `folderId` query parameter.
	FolderId *string `json:"folderId,omitempty"`

	// An optional doc ID from which to create a copy.
	SourceDoc *string `json:"sourceDoc,omitempty"`

	// The timezone to use for the newly created doc.
	Timezone *string `json:"timezone,omitempty"`

	// Title of the new doc. Defaults to 'Untitled'.
	Title *string `json:"title,omitempty"`
}

// The result of a doc deletion.
type DocDelete map[string]interface{}

// List of Coda docs.
type DocList struct {
	// API link to these results
	Href         *string `json:"href,omitempty"`
	Items        []Doc   `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Payload for publishing a doc or or updating its publishing information.
type DocPublish struct {
	// The names of categories to apply to the document.
	CategoryNames *[]string `json:"categoryNames,omitempty"`

	// If true, indicates that the doc is discoverable.
	Discoverable *bool `json:"discoverable,omitempty"`

	// If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
	EarnCredit *bool `json:"earnCredit,omitempty"`

	// A time unit used as part of a duration value.
	Mode *DocPublishMode `json:"mode,omitempty"`

	// Slug for the published doc.
	Slug *string `json:"slug,omitempty"`
}

// A time unit used as part of a duration value.
type DocPublishMode string

// Information about the publishing state of the document.
type DocPublished struct {
	// URL to the published doc.
	BrowserLink string `json:"browserLink"`

	// Categories applied to the doc.
	Categories []DocCategory `json:"categories"`

	// Description of the published doc.
	Description *string `json:"description,omitempty"`

	// If true, indicates that the doc is discoverable.
	Discoverable bool `json:"discoverable"`

	// If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
	EarnCredit bool `json:"earnCredit"`

	// URL to the cover image for the published doc.
	ImageLink *string `json:"imageLink,omitempty"`

	// A time unit used as part of a duration value.
	Mode DocPublishMode `json:"mode"`
}

// Reference to a Coda doc.
type DocReference struct {
	// Browser-friendly link to the Coda doc.
	BrowserLink string `json:"browserLink"`

	// API link to the Coda doc.
	Href string `json:"href"`

	// ID of the Coda doc.
	Id string `json:"id"`

	// The type of this resource.
	Type DocReferenceType `json:"type"`
}

// The type of this resource.
type DocReferenceType string

// The number of components within a Coda doc.
type DocSize struct {
	// If true, indicates that the doc is over the API size limit.
	OverApiSizeLimit bool `json:"overApiSizeLimit"`

	// The total number of page contained within the doc.
	PageCount float32 `json:"pageCount"`

	// The total number of tables and views contained within the doc.
	TableAndViewCount float32 `json:"tableAndViewCount"`

	// The number of rows contained within all tables of the doc.
	TotalRowCount float32 `json:"totalRowCount"`
}

// The result of a doc creation.
type DocumentCreationResult struct {
	// Browser-friendly link to the Coda doc.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the doc was created.
	CreatedAt time.Time `json:"createdAt"`

	// The number of components within a Coda doc.
	DocSize *DocSize `json:"docSize,omitempty"`

	// Reference to a Coda folder.
	Folder FolderReference `json:"folder"`

	// ID of the Coda folder containing this doc.
	FolderId string `json:"folderId"`

	// API link to the Coda doc.
	Href string `json:"href"`

	// Info about the icon.
	Icon *Icon `json:"icon,omitempty"`

	// ID of the Coda doc.
	Id string `json:"id"`

	// Name of the doc.
	Name string `json:"name"`

	// Email address of the doc owner.
	Owner openapi_types.Email `json:"owner"`

	// Name of the doc owner.
	OwnerName string `json:"ownerName"`

	// Information about the publishing state of the document.
	Published *DocPublished `json:"published,omitempty"`

	// An arbitrary unique identifier for this request.
	RequestId *string `json:"requestId,omitempty"`
	SourceDoc *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/DocReference)
		DocReference `yaml:",inline"`
	} `json:"sourceDoc,omitempty"`

	// The type of this resource.
	Type DocumentCreationResultType `json:"type"`

	// Timestamp for when the doc was last modified.
	UpdatedAt time.Time `json:"updatedAt"`

	// Reference to a Coda workspace.
	Workspace WorkspaceReference `json:"workspace"`

	// ID of the Coda workspace containing this doc.
	WorkspaceId string `json:"workspaceId"`
}

// The type of this resource.
type DocumentCreationResultType string

// Base response type for an operation that mutates a document.
type DocumentMutateResponse struct {
	// An arbitrary unique identifier for this request.
	RequestId string `json:"requestId"`
}

// DomainPrincipal defines model for DomainPrincipal.
type DomainPrincipal struct {
	// Domain for the principal.
	Domain string `json:"domain"`

	// Type of principal.
	Type PrincipalType `json:"type"`
}

// DurationColumnFormat defines model for DurationColumnFormat.
type DurationColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	MaxUnit *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/DurationUnit)
		DurationUnit `yaml:",inline"`
	} `json:"maxUnit,omitempty"`
	Precision *int `json:"precision,omitempty"`
}

// A time unit used as part of a duration value.
type DurationUnit string

// EmailColumnFormat defines model for EmailColumnFormat.
type EmailColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Autocomplete *bool `json:"autocomplete,omitempty"`

	// How an email address should be displayed in the user interface.
	Display *EmailDisplayType `json:"display,omitempty"`
}

// How an email address should be displayed in the user interface.
type EmailDisplayType string

// EmailPrincipal defines model for EmailPrincipal.
type EmailPrincipal struct {
	// Email for the principal.
	Email string `json:"email"`

	// Type of principal.
	Type PrincipalType `json:"type"`
}

// Reference to a Coda folder.
type FolderReference struct {
	// Browser-friendly link to the folder.
	BrowserLink string `json:"browserLink"`

	// ID of the Coda folder.
	Id string `json:"id"`

	// The type of this resource.
	Type FolderReferenceType `json:"type"`
}

// The type of this resource.
type FolderReferenceType string

// Details about a formula.
type Formula struct {
	// API link to the formula.
	Href string `json:"href"`

	// ID of the formula.
	Id string `json:"id"`

	// Name of the formula.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type FormulaType `json:"type"`

	// A Coda result or entity expressed as a primitive type, or array of primitive types.
	Value Value `json:"value"`
}

// The type of this resource.
type FormulaType string

// Detailed information about a formula.
type FormulaDetail struct {
	// Returns whether or not the given formula has a Now() formula within it.
	HasNowFormula *bool `json:"hasNowFormula,omitempty"`

	// Returns whether or not the given formula has a Today() formula within it.
	HasTodayFormula *bool `json:"hasTodayFormula,omitempty"`

	// Returns whether or not the given formula has a User() formula within it.
	HasUserFormula *bool `json:"hasUserFormula,omitempty"`

	// Returns whether or not the given formula can return different results in different contexts (for example, for different users).
	IsVolatile *bool `json:"isVolatile,omitempty"`

	// Returns whether or not the given formula is valid.
	Valid bool `json:"valid"`
}

// List of formulas.
type FormulaList struct {
	// API link to these results
	Href         *string            `json:"href,omitempty"`
	Items        []FormulaReference `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Reference to a formula.
type FormulaReference struct {
	// API link to the formula.
	Href string `json:"href"`

	// ID of the formula.
	Id string `json:"id"`

	// Name of the formula.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type FormulaReferenceType `json:"type"`
}

// The type of this resource.
type FormulaReferenceType string

// Response for getting workspace role activity.
type GetWorkspaceRoleActivity struct {
	Items []WorkspaceRoleActivity `json:"items"`
}

// Info about the icon.
type Icon struct {
	// Browser-friendly link to an icon.
	BrowserLink string `json:"browserLink"`

	// Name of the icon.
	Name string `json:"name"`

	// MIME type of the icon
	Type string `json:"type"`
}

// List of available icon sets.
type IconSet string

// Info about the image.
type Image struct {
	// Browser-friendly link to an image.
	BrowserLink string `json:"browserLink"`

	// The height in pixels of the image.
	Height *float32 `json:"height,omitempty"`

	// MIME type of the image.
	Type *string `json:"type,omitempty"`

	// The width in pixels of the image.
	Width *float32 `json:"width,omitempty"`
}

// The status values that an image object can have.
type ImageStatus string

// ImageUrlValue defines model for ImageUrlValue.
type ImageUrlValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The height of the image in pixels.
	Height *float32 `json:"height,omitempty"`

	// The name of the image.
	Name *string `json:"name,omitempty"`

	// The status values that an image object can have.
	Status *ImageStatus `json:"status,omitempty"`

	// The url of the image.
	Url *string `json:"url,omitempty"`

	// The width of the image in pixels.
	Width *float32 `json:"width,omitempty"`
}

// Layout type of the table or view.
type Layout string

// Base type for a JSON-LD (Linked Data) object.
type LinkedDataObject struct {
	// A url describing the schema context for this object, typically "http://schema.org/".
	Context string `json:"@context"`

	// A schema.org identifier for the object.
	Type LinkedDataType `json:"@type"`

	// An identifier of additional type info specific to Coda that may not be present in a schema.org taxonomy,
	AdditionalType *string `json:"additionalType,omitempty"`
}

// A schema.org identifier for the object.
type LinkedDataType string

// The status of an asynchronous mutation.
type MutationStatus struct {
	// Returns whether the mutation has completed.
	Completed bool `json:"completed"`
}

// A number or a string representing a formula that evaluates to a number.
type NumberOrNumberFormula interface{}

// NumericColumnFormat defines model for NumericColumnFormat.
type NumericColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The decimal precision.
	Precision *int `json:"precision,omitempty"`

	// Whether to use a thousands separator (like ",") to format the numeric value.
	UseThousandsSeparator *bool `json:"useThousandsSeparator,omitempty"`
}

// Metadata about a page.
type Page struct {
	// Browser-friendly link to the page.
	BrowserLink string          `json:"browserLink"`
	Children    []PageReference `json:"children"`

	// API link to the page.
	Href string `json:"href"`

	// Info about the icon.
	Icon *Icon `json:"icon,omitempty"`

	// ID of the page.
	Id string `json:"id"`

	// Info about the image.
	Image *Image `json:"image,omitempty"`

	// Name of the page.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// Subtitle of the page.
	Subtitle *string `json:"subtitle,omitempty"`

	// The type of this resource.
	Type PageType `json:"type"`
}

// The type of this resource.
type PageType string

// List of pages.
type PageList struct {
	// API link to these results
	Href         *string `json:"href,omitempty"`
	Items        []Page  `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Reference to a page.
type PageReference struct {
	// Browser-friendly link to the page.
	BrowserLink string `json:"browserLink"`

	// API link to the page.
	Href string `json:"href"`

	// ID of the page.
	Id string `json:"id"`

	// Name of the page.
	Name string `json:"name"`

	// The type of this resource.
	Type PageReferenceType `json:"type"`
}

// The type of this resource.
type PageReferenceType string

// Payload for updating a page.
type PageUpdate struct {
	// Name of the icon.
	IconName *string `json:"iconName,omitempty"`

	// Url of the image to use.
	ImageUrl *string `json:"imageUrl,omitempty"`

	// Name of the page.
	Name *string `json:"name,omitempty"`

	// Subtitle of the page.
	Subtitle *string `json:"subtitle,omitempty"`
}

// PageUpdateResult defines model for PageUpdateResult.
type PageUpdateResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// ID of the updated page.
	Id string `json:"id"`
}

// A specific premission granted to a principal.
type Permission struct {
	// Type of access.
	Access AccessType `json:"access"`

	// Id for the Permission
	Id string `json:"id"`

	// Metadata about a principal.
	Principal Principal `json:"principal"`
}

// PersonValue defines model for PersonValue.
type PersonValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The email address of the person.
	Email string `json:"email"`

	// The full name of the person.
	Name string `json:"name"`
}

// Metadata about a principal.
type Principal interface{}

// Type of principal.
type PrincipalType string

// PublishResult defines model for PublishResult.
type PublishResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
}

// PushButtonResult defines model for PushButtonResult.
type PushButtonResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// ID of the column where the button exists.
	ColumnId string `json:"columnId"`

	// ID of the row where the button exists.
	RowId string `json:"rowId"`
}

// ReferenceColumnFormat defines model for ReferenceColumnFormat.
type ReferenceColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Table struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/TableReference)
		TableReference `yaml:",inline"`
	} `json:"table"`
}

// A value that contains rich structured data. Cell values are composed of these values or arrays of these values.
type RichSingleValue interface{}

// A cell value that contains rich structured data.
type RichValue interface{}

// Info about a row.
type Row struct {
	// Browser-friendly link to the row.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the row was created.
	CreatedAt time.Time `json:"createdAt"`

	// API link to the row.
	Href string `json:"href"`

	// ID of the row.
	Id string `json:"id"`

	// Index of the row within the table.
	Index int `json:"index"`

	// The display name of the row, based on its identifying column.
	Name string `json:"name"`

	// The type of this resource.
	Type RowType `json:"type"`

	// Timestamp for when the row was last modified.
	UpdatedAt time.Time `json:"updatedAt"`

	// Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
	Values Row_Values `json:"values"`
}

// The type of this resource.
type RowType string

// Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
type Row_Values struct {
	AdditionalProperties map[string]CellValue `json:"-"`
}

// RowDeleteResult defines model for RowDeleteResult.
type RowDeleteResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// ID of the row to be deleted.
	Id string `json:"id"`
}

// Details about a row.
type RowDetail struct {
	// Browser-friendly link to the row.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the row was created.
	CreatedAt time.Time `json:"createdAt"`

	// API link to the row.
	Href string `json:"href"`

	// ID of the row.
	Id string `json:"id"`

	// Index of the row within the table.
	Index int `json:"index"`

	// The display name of the row, based on its identifying column.
	Name string `json:"name"`

	// Reference to a table or view.
	Parent TableReference `json:"parent"`

	// The type of this resource.
	Type RowDetailType `json:"type"`

	// Timestamp for when the row was last modified.
	UpdatedAt time.Time `json:"updatedAt"`

	// Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
	Values RowDetail_Values `json:"values"`
}

// The type of this resource.
type RowDetailType string

// Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
type RowDetail_Values struct {
	AdditionalProperties map[string]CellValue `json:"-"`
}

// An edit made to a particular row.
type RowEdit struct {
	Cells []CellEdit `json:"cells"`
}

// List of rows.
type RowList struct {
	// API link to these results
	Href         *string `json:"href,omitempty"`
	Items        []Row   `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`

	// If specified, an opaque token that can be passed back later to retrieve new results that match the parameters specified when the sync token was created.
	NextSyncToken *NextSyncToken `json:"nextSyncToken,omitempty"`
}

// Payload for updating a row in a table.
type RowUpdate struct {
	// An edit made to a particular row.
	Row RowEdit `json:"row"`
}

// RowUpdateResult defines model for RowUpdateResult.
type RowUpdateResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// ID of the updated row.
	Id string `json:"id"`
}

// RowValue defines model for RowValue.
type RowValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The type of this resource.
	AdditionalType RowValueAdditionalType `json:"additionalType"`

	// The display name of the row, based on its identifying column.
	Name string `json:"name"`

	// The ID of the table
	RowId string `json:"rowId"`

	// The ID of the table
	TableId string `json:"tableId"`

	// The url of the table.
	TableUrl string `json:"tableUrl"`

	// The url of the row.
	Url string `json:"url"`
}

// The type of this resource.
type RowValueAdditionalType string

// Payload for deleting rows from a table.
type RowsDelete struct {
	// Row IDs to delete.
	RowIds []string `json:"rowIds"`
}

// RowsDeleteResult defines model for RowsDeleteResult.
type RowsDeleteResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Row IDs to delete.
	RowIds []string `json:"rowIds"`
}

// Determines how the rows returned are sorted
type RowsSortBy string

// Payload for upserting rows in a table.
type RowsUpsert struct {
	// Optional column IDs, URLs, or names (fragile and discouraged), specifying columns to be used as upsert keys.
	KeyColumns *[]string `json:"keyColumns,omitempty"`
	Rows       []RowEdit `json:"rows"`
}

// RowsUpsertResult defines model for RowsUpsertResult.
type RowsUpsertResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// Row IDs for rows that will be added. Only applicable when keyColumns is not set or empty.
	AddedRowIds *[]string `json:"addedRowIds,omitempty"`
}

// A Coda result or entity expressed as a primitive type.
type ScalarValue interface{}

// ScaleColumnFormat defines model for ScaleColumnFormat.
type ScaleColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Icon struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/IconSet)
		IconSet `yaml:",inline"`
	} `json:"icon"`

	// The maximum number allowed for this scale.
	Maximum float32 `json:"maximum"`
}

// Format of a simple column.
type SimpleColumnFormat struct {
	// Whether or not this column is an array.
	IsArray bool `json:"isArray"`

	// Format type of the column
	Type ColumnFormatType `json:"type"`
}

// SliderColumnFormat defines model for SliderColumnFormat.
type SliderColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Maximum *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/NumberOrNumberFormula)
		NumberOrNumberFormula `yaml:",inline"`
	} `json:"maximum,omitempty"`
	Minimum *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/NumberOrNumberFormula)
		NumberOrNumberFormula `yaml:",inline"`
	} `json:"minimum,omitempty"`
	Step *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/NumberOrNumberFormula)
		NumberOrNumberFormula `yaml:",inline"`
	} `json:"step,omitempty"`
}

// A sort applied to a table or view.
type Sort struct {
	// Reference to a column.
	Column ColumnReference `json:"column"`

	// Direction of a sort for a table or view.
	Direction SortDirection `json:"direction"`
}

// Determines how the objects returned are sorted
type SortBy string

// Direction of a sort for a table or view.
type SortDirection string

// Metadata about a table.
type Table struct {
	// Browser-friendly link to the table.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the table was created.
	CreatedAt time.Time `json:"createdAt"`

	// Reference to a column.
	DisplayColumn ColumnReference `json:"displayColumn"`
	Filter        *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/FormulaDetail)
		FormulaDetail `yaml:",inline"`
	} `json:"filter,omitempty"`

	// API link to the table.
	Href string `json:"href"`

	// ID of the table.
	Id string `json:"id"`

	// Layout type of the table or view.
	Layout Layout `json:"layout"`

	// Name of the table.
	Name string `json:"name"`

	// Reference to a page.
	Parent PageReference `json:"parent"`

	// Reference to a table or view.
	ParentTable *TableReference `json:"parentTable,omitempty"`

	// Total number of rows in the table.
	RowCount int `json:"rowCount"`

	// Any sorts applied to the table.
	Sorts     []Sort    `json:"sorts"`
	TableType TableType `json:"tableType"`

	// The type of this resource.
	Type TableType `json:"type"`

	// Timestamp for when the table was last modified.
	UpdatedAt time.Time `json:"updatedAt"`
}

// The type of this resource.
type TableType string

// List of tables.
type TableList struct {
	// API link to these results
	Href         *string          `json:"href,omitempty"`
	Items        []TableReference `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Reference to a table or view.
type TableReference struct {
	// Browser-friendly link to the table.
	BrowserLink string `json:"browserLink"`

	// API link to the table.
	Href string `json:"href"`

	// ID of the table.
	Id string `json:"id"`

	// Name of the table.
	Name string `json:"name"`

	// Reference to a page.
	Parent    *PageReference `json:"parent,omitempty"`
	TableType TableType      `json:"tableType"`

	// The type of this resource.
	Type TableReferenceType `json:"type"`
}

// The type of this resource.
type TableReferenceType string

// TimeColumnFormat defines model for TimeColumnFormat.
type TimeColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	Format *string `json:"format,omitempty"`
}

// A constant identifying the type of the resource.
type Type string

// The result of unpublishing a doc.
type UnpublishResult map[string]interface{}

// UrlValue defines model for UrlValue.
type UrlValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// The user-visible text of the hyperlink.
	Name *string `json:"name,omitempty"`

	// The url of the hyperlink.
	Url string `json:"url"`
}

// Info about the user.
type User struct {
	// API link to the user.
	Href string `json:"href"`

	// Email address of the user.
	LoginId string `json:"loginId"`

	// Name of the user.
	Name string `json:"name"`

	// Browser-friendly link to the user's avatar image.
	PictureLink *string `json:"pictureLink,omitempty"`

	// True if the token used to make this request has restricted/scoped access to the API.
	Scoped bool `json:"scoped"`

	// Returns the name of the token used for this request.
	TokenName string `json:"tokenName"`

	// The type of this resource.
	Type UserType `json:"type"`

	// Reference to a Coda workspace.
	Workspace WorkspaceReference `json:"workspace"`
}

// The type of this resource.
type UserType string

// A Coda result or entity expressed as a primitive type, or array of primitive types.
type Value interface{}

// The format that cell values are returned as.
type ValueFormat string

// Response for listing workspace users.
type WorkspaceMembersList struct {
	Items        []WorkspaceUser `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// Reference to a Coda workspace.
type WorkspaceReference struct {
	// Browser-friendly link to the Coda workspace.
	BrowserLink string `json:"browserLink"`

	// ID of the Coda workspace.
	Id string `json:"id"`

	// ID of the organization bound to this workspace, if any.
	OrganizationId *string `json:"organizationId,omitempty"`

	// The type of this resource.
	Type WorkspaceReferenceType `json:"type"`
}

// The type of this resource.
type WorkspaceReferenceType string

// Metadata for workspace role activity.
type WorkspaceRoleActivity struct {
	// Number of active Admins.
	ActiveAdminCount float32 `json:"activeAdminCount"`

	// Number of active Doc Makers.
	ActiveDocMakerCount float32 `json:"activeDocMakerCount"`

	// Number of active Editors.
	ActiveEditorCount float32 `json:"activeEditorCount"`

	// Number of inactive Admins.
	InactiveAdminCount float32 `json:"inactiveAdminCount"`

	// Number of inactive Doc Makers.
	InactiveDocMakerCount float32 `json:"inactiveDocMakerCount"`

	// Number of inactive Editor users.
	InactiveEditorCount float32 `json:"inactiveEditorCount"`

	// Month corresponding to the data.
	Month string `json:"month"`
}

// Metadata of a workspace user.
type WorkspaceUser struct {
	// Number of collaborators that have interacted with docs owned by the user.
	DocCollaboratorCount *float32 `json:"docCollaboratorCount,omitempty"`

	// Timestamp for when someone last loaded a doc that the user owns in this workspace.
	DocsLastActiveAt *time.Time `json:"docsLastActiveAt,omitempty"`

	// Email of the user.
	Email string `json:"email"`

	// Timestamp for when the user last took an action in this workspace.
	LastActiveAt *time.Time `json:"lastActiveAt,omitempty"`

	// Name of the user.
	Name string `json:"name"`

	// List of IDs of docs owned by the user.
	OwnedDocIds *[]string `json:"ownedDocIds,omitempty"`

	// Picture url of the user.
	PictureUrl *string `json:"pictureUrl,omitempty"`

	// Timestamp for when the user registered in this workspace
	RegisteredAt time.Time         `json:"registeredAt"`
	Role         WorkspaceUserRole `json:"role"`

	// Timestamp for when the user's role last changed in this workspace.
	RoleChangedAt time.Time `json:"roleChangedAt"`
}

// WorkspaceUserRole defines model for WorkspaceUserRole.
type WorkspaceUserRole string

// If specified, a link that can be used to fetch the next page of results.
type NextPageLink string

// If specified, an opaque token used to fetch the next page of results.
type NextPageToken string

// If specified, an opaque token that can be passed back later to retrieve new results that match the parameters specified when the sync token was created.
type NextSyncToken string

// ColumnIdOrName defines model for columnIdOrName.
type ColumnIdOrName string

// ControlIdOrName defines model for controlIdOrName.
type ControlIdOrName string

// DocId defines model for docId.
type DocId string

// FormulaIdOrName defines model for formulaIdOrName.
type FormulaIdOrName string

// Limit defines model for limit.
type Limit int

// PageIdOrName defines model for pageIdOrName.
type PageIdOrName string

// PageToken defines model for pageToken.
type PageToken string

// PermissionId defines model for permissionId.
type PermissionId string

// RequestId defines model for requestId.
type RequestId string

// RowIdOrName defines model for rowIdOrName.
type RowIdOrName string

// SyncToken defines model for syncToken.
type SyncToken string

// TableIdOrName defines model for tableIdOrName.
type TableIdOrName string

// TableTypes defines model for tableTypes.
type TableTypes []TableType

// UseColumnNames defines model for useColumnNames.
type UseColumnNames bool

// WorkspaceId defines model for workspaceId.
type WorkspaceId string

// An HTTP error resulting from an unsuccessful request.
type BadRequestError struct {
	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// An HTTP error resulting from an unsuccessful request.
type ForbiddenError struct {
	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// An HTTP error resulting from an unsuccessful request.
type GoneError struct {
	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// An HTTP error resulting from an unsuccessful request.
type NotFoundError struct {
	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// An HTTP error resulting from an unsuccessful request.
type TooManyRequestsError struct {
	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// An HTTP error resulting from an unsuccessful request.
type UnauthorizedError struct {
	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// ListDocAnalyticsParams defines parameters for ListDocAnalytics.
type ListDocAnalyticsParams struct {
	// Show analytics only for published docs.
	IsPublished *bool `json:"isPublished,omitempty"`

	// Limit results to activity on or after this date.
	SinceDate *openapi_types.Date `json:"sinceDate,omitempty"`

	// Limit results to activity on or before this date.
	UntilDate *openapi_types.Date `json:"untilDate,omitempty"`

	// Quantization period over which to view analytics. Defaults to daily.
	Scale *DocAnalyticsScale `json:"scale,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// ListDocsParams defines parameters for ListDocs.
type ListDocsParams struct {
	// Show only docs owned by the user.
	IsOwner *bool `json:"isOwner,omitempty"`

	// Show only published docs.
	IsPublished *bool `json:"isPublished,omitempty"`

	// Search term used to filter down results.
	Query *string `json:"query,omitempty"`

	// Show only docs copied from the specified doc ID.
	SourceDoc *string `json:"sourceDoc,omitempty"`

	// If true, returns docs that are starred. If false, returns docs that are not starred.
	IsStarred *bool `json:"isStarred,omitempty"`

	// Show only docs visible within the gallery.
	InGallery *bool `json:"inGallery,omitempty"`

	// Show only docs belonging to the given workspace.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// Show only docs belonging to the given folder.
	FolderId *string `json:"folderId,omitempty"`

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// CreateDocJSONBody defines parameters for CreateDoc.
type CreateDocJSONBody DocCreate

// GetPermissionsParams defines parameters for GetPermissions.
type GetPermissionsParams struct {
	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// AddPermissionJSONBody defines parameters for AddPermission.
type AddPermissionJSONBody AddPermissionRequest

// ListControlsParams defines parameters for ListControls.
type ListControlsParams struct {
	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// Determines how to sort the given objects.
	SortBy *SortBy `json:"sortBy,omitempty"`
}

// ListFormulasParams defines parameters for ListFormulas.
type ListFormulasParams struct {
	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// Determines how to sort the given objects.
	SortBy *SortBy `json:"sortBy,omitempty"`
}

// ListPagesParams defines parameters for ListPages.
type ListPagesParams struct {
	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// UpdatePageJSONBody defines parameters for UpdatePage.
type UpdatePageJSONBody PageUpdate

// PublishDocJSONBody defines parameters for PublishDoc.
type PublishDocJSONBody DocPublish

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {
	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// Determines how to sort the given objects.
	SortBy *SortBy `json:"sortBy,omitempty"`

	// Comma-separated list of table types to include in results. If omitted, includes both tables and views.
	TableTypes *TableTypes `json:"tableTypes,omitempty"`
}

// GetTableParams defines parameters for GetTable.
type GetTableParams struct {
	// Return "detail" and "form" for the `layout` field of detail and form layouts respectively (instead of "masterDetail" for both)
	UseUpdatedTableLayouts *bool `json:"useUpdatedTableLayouts,omitempty"`
}

// ListColumnsParams defines parameters for ListColumns.
type ListColumnsParams struct {
	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// If true, returns only visible columns for the table.
	VisibleOnly *bool `json:"visibleOnly,omitempty"`
}

// DeleteRowsJSONBody defines parameters for DeleteRows.
type DeleteRowsJSONBody RowsDelete

// ListRowsParams defines parameters for ListRows.
type ListRowsParams struct {
	// Query used to filter returned rows, specified as `<column_id_or_name>:<value>`. If you'd like to use a column name instead of an ID, you must quote it (e.g., `"My Column":123`). Also note that `value` is a JSON value; if you'd like to use a string, you must surround it in quotes (e.g., `"groceries"`).
	Query *string `json:"query,omitempty"`

	// Specifies the sort order of the rows returned. If left unspecified, rows are returned by creation time ascending. "UpdatedAt" sort ordering is the order of rows based upon when they were last updated. This does not include updates to calculated values. "Natural" sort ordering is the order that the rows appear in the table view in the application. This ordering is only meaningfully defined for rows that are visible (unfiltered). Because of this, using this sort order will imply visibleOnly=true, that is, to only return visible rows. If you pass sortBy=natural and visibleOnly=false explicitly, this will result in a Bad Request error as this condition cannot be satisfied.
	SortBy *RowsSortBy `json:"sortBy,omitempty"`

	// Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
	UseColumnNames *UseColumnNames `json:"useColumnNames,omitempty"`

	// The format that cell values are returned as.
	ValueFormat *ValueFormat `json:"valueFormat,omitempty"`

	// If true, returns only visible rows and columns for the table.
	VisibleOnly *bool `json:"visibleOnly,omitempty"`

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// An opaque token returned from a previous call that can be used to return results that are relevant to the query since the call where the syncToken was generated.
	SyncToken *SyncToken `json:"syncToken,omitempty"`
}

// UpsertRowsJSONBody defines parameters for UpsertRows.
type UpsertRowsJSONBody RowsUpsert

// UpsertRowsParams defines parameters for UpsertRows.
type UpsertRowsParams struct {
	// If true, the API will not attempt to parse the data in any way.
	DisableParsing *bool `json:"disableParsing,omitempty"`
}

// GetRowParams defines parameters for GetRow.
type GetRowParams struct {
	// Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
	UseColumnNames *UseColumnNames `json:"useColumnNames,omitempty"`

	// The format that cell values are returned as.
	ValueFormat *ValueFormat `json:"valueFormat,omitempty"`
}

// UpdateRowJSONBody defines parameters for UpdateRow.
type UpdateRowJSONBody RowUpdate

// UpdateRowParams defines parameters for UpdateRow.
type UpdateRowParams struct {
	// If true, the API will not attempt to parse the data in any way.
	DisableParsing *bool `json:"disableParsing,omitempty"`
}

// ResolveBrowserLinkParams defines parameters for ResolveBrowserLink.
type ResolveBrowserLinkParams struct {
	// The browser link to try to resolve.
	Url string `json:"url"`

	// By default, attempting to resolve the Coda URL of a deleted object will result in an error. If this flag is set, the next-available object, all the way up to the doc itself, will be resolved.
	DegradeGracefully *bool `json:"degradeGracefully,omitempty"`
}

// ListWorkspaceMembersParams defines parameters for ListWorkspaceMembers.
type ListWorkspaceMembersParams struct {
	// Show only the members that match the included roles. Multiple roles can be specified with a comma-delimited list.
	IncludedRoles *[]WorkspaceUserRole `json:"includedRoles,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// ChangeUserRoleJSONBody defines parameters for ChangeUserRole.
type ChangeUserRoleJSONBody ChangeRole

// CreateDocJSONRequestBody defines body for CreateDoc for application/json ContentType.
type CreateDocJSONRequestBody CreateDocJSONBody

// AddPermissionJSONRequestBody defines body for AddPermission for application/json ContentType.
type AddPermissionJSONRequestBody AddPermissionJSONBody

// UpdatePageJSONRequestBody defines body for UpdatePage for application/json ContentType.
type UpdatePageJSONRequestBody UpdatePageJSONBody

// PublishDocJSONRequestBody defines body for PublishDoc for application/json ContentType.
type PublishDocJSONRequestBody PublishDocJSONBody

// DeleteRowsJSONRequestBody defines body for DeleteRows for application/json ContentType.
type DeleteRowsJSONRequestBody DeleteRowsJSONBody

// UpsertRowsJSONRequestBody defines body for UpsertRows for application/json ContentType.
type UpsertRowsJSONRequestBody UpsertRowsJSONBody

// UpdateRowJSONRequestBody defines body for UpdateRow for application/json ContentType.
type UpdateRowJSONRequestBody UpdateRowJSONBody

// ChangeUserRoleJSONRequestBody defines body for ChangeUserRole for application/json ContentType.
type ChangeUserRoleJSONRequestBody ChangeUserRoleJSONBody

// Getter for additional properties for Row_Values. Returns the specified
// element and whether it was found
func (a Row_Values) Get(fieldName string) (value CellValue, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Row_Values
func (a *Row_Values) Set(fieldName string, value CellValue) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CellValue)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Row_Values to handle AdditionalProperties
func (a *Row_Values) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CellValue)
		for fieldName, fieldBuf := range object {
			var fieldVal CellValue
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Row_Values to handle AdditionalProperties
func (a Row_Values) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RowDetail_Values. Returns the specified
// element and whether it was found
func (a RowDetail_Values) Get(fieldName string) (value CellValue, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RowDetail_Values
func (a *RowDetail_Values) Set(fieldName string, value CellValue) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CellValue)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RowDetail_Values to handle AdditionalProperties
func (a *RowDetail_Values) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CellValue)
		for fieldName, fieldBuf := range object {
			var fieldVal CellValue
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RowDetail_Values to handle AdditionalProperties
func (a RowDetail_Values) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListDocAnalytics request
	ListDocAnalytics(ctx context.Context, params *ListDocAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCategories request
	ListCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDocs request
	ListDocs(ctx context.Context, params *ListDocsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDoc request with any body
	CreateDocWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDoc(ctx context.Context, body CreateDocJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDoc request
	DeleteDoc(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDoc request
	GetDoc(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSharingMetadata request
	GetSharingMetadata(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissions request
	GetPermissions(ctx context.Context, docId DocId, params *GetPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPermission request with any body
	AddPermissionWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPermission(ctx context.Context, docId DocId, body AddPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePermission request
	DeletePermission(ctx context.Context, docId DocId, permissionId PermissionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListControls request
	ListControls(ctx context.Context, docId DocId, params *ListControlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetControl request
	GetControl(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFormulas request
	ListFormulas(ctx context.Context, docId DocId, params *ListFormulasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFormula request
	GetFormula(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPages request
	ListPages(ctx context.Context, docId DocId, params *ListPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPage request
	GetPage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePage request with any body
	UpdatePageWithBody(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpublishDoc request
	UnpublishDoc(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishDoc request with any body
	PublishDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishDoc(ctx context.Context, docId DocId, body PublishDocJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, docId DocId, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListColumns request
	ListColumns(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetColumn request
	GetColumn(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRows request with any body
	DeleteRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRows request
	ListRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertRows request with any body
	UpsertRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRow request
	DeleteRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRow request
	GetRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRow request with any body
	UpdateRowWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushButton request
	PushButton(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMutationStatus request
	GetMutationStatus(ctx context.Context, requestId RequestId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveBrowserLink request
	ResolveBrowserLink(ctx context.Context, params *ResolveBrowserLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whoami request
	Whoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceRoleActivity request
	ListWorkspaceRoleActivity(ctx context.Context, workspaceId WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceMembers request
	ListWorkspaceMembers(ctx context.Context, workspaceId WorkspaceId, params *ListWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeUserRole request with any body
	ChangeUserRoleWithBody(ctx context.Context, workspaceId WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeUserRole(ctx context.Context, workspaceId WorkspaceId, body ChangeUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListDocAnalytics(ctx context.Context, params *ListDocAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDocAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDocs(ctx context.Context, params *ListDocsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDocsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDoc(ctx context.Context, body CreateDocJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDoc(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDoc(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSharingMetadata(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSharingMetadataRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissions(ctx context.Context, docId DocId, params *GetPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPermissionWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPermissionRequestWithBody(c.Server, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPermission(ctx context.Context, docId DocId, body AddPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPermissionRequest(c.Server, docId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePermission(ctx context.Context, docId DocId, permissionId PermissionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePermissionRequest(c.Server, docId, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListControls(ctx context.Context, docId DocId, params *ListControlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListControlsRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetControl(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetControlRequest(c.Server, docId, controlIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFormulas(ctx context.Context, docId DocId, params *ListFormulasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFormulasRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFormula(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFormulaRequest(c.Server, docId, formulaIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPages(ctx context.Context, docId DocId, params *ListPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPagesRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageRequest(c.Server, docId, pageIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePageWithBody(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePageRequestWithBody(c.Server, docId, pageIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePageRequest(c.Server, docId, pageIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpublishDoc(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpublishDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishDocRequestWithBody(c.Server, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishDoc(ctx context.Context, docId DocId, body PublishDocJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishDocRequest(c.Server, docId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, docId DocId, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListColumns(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListColumnsRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumn(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetColumnRequest(c.Server, docId, tableIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRowsRequestWithBody(c.Server, docId, tableIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRowsRequest(c.Server, docId, tableIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRowsRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRowsRequestWithBody(c.Server, docId, tableIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRowsRequest(c.Server, docId, tableIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRowRequest(c.Server, docId, tableIdOrName, rowIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRowRequest(c.Server, docId, tableIdOrName, rowIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRowWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRowRequestWithBody(c.Server, docId, tableIdOrName, rowIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRowRequest(c.Server, docId, tableIdOrName, rowIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushButton(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushButtonRequest(c.Server, docId, tableIdOrName, rowIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMutationStatus(ctx context.Context, requestId RequestId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMutationStatusRequest(c.Server, requestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveBrowserLink(ctx context.Context, params *ResolveBrowserLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveBrowserLinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoamiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceRoleActivity(ctx context.Context, workspaceId WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceRoleActivityRequest(c.Server, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceMembers(ctx context.Context, workspaceId WorkspaceId, params *ListWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceMembersRequest(c.Server, workspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeUserRoleWithBody(ctx context.Context, workspaceId WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeUserRoleRequestWithBody(c.Server, workspaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeUserRole(ctx context.Context, workspaceId WorkspaceId, body ChangeUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeUserRoleRequest(c.Server, workspaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListDocAnalyticsRequest generates requests for ListDocAnalytics
func NewListDocAnalyticsRequest(server string, params *ListDocAnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/docs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsPublished != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublished", runtime.ParamLocationQuery, *params.IsPublished); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SinceDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinceDate", runtime.ParamLocationQuery, *params.SinceDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UntilDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "untilDate", runtime.ParamLocationQuery, *params.UntilDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Scale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scale", runtime.ParamLocationQuery, *params.Scale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCategoriesRequest generates requests for ListCategories
func NewListCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDocsRequest generates requests for ListDocs
func NewListDocsRequest(server string, params *ListDocsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isOwner", runtime.ParamLocationQuery, *params.IsOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsPublished != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublished", runtime.ParamLocationQuery, *params.IsPublished); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SourceDoc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceDoc", runtime.ParamLocationQuery, *params.SourceDoc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsStarred != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isStarred", runtime.ParamLocationQuery, *params.IsStarred); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InGallery != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inGallery", runtime.ParamLocationQuery, *params.InGallery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.WorkspaceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workspaceId", runtime.ParamLocationQuery, *params.WorkspaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FolderId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDocRequest calls the generic CreateDoc builder with application/json body
func NewCreateDocRequest(server string, body CreateDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDocRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDocRequestWithBody generates requests for CreateDoc with any type of body
func NewCreateDocRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDocRequest generates requests for DeleteDoc
func NewDeleteDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDocRequest generates requests for GetDoc
func NewGetDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSharingMetadataRequest generates requests for GetSharingMetadata
func NewGetSharingMetadataRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/acl/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionsRequest generates requests for GetPermissions
func NewGetPermissionsRequest(server string, docId DocId, params *GetPermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/acl/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPermissionRequest calls the generic AddPermission builder with application/json body
func NewAddPermissionRequest(server string, docId DocId, body AddPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPermissionRequestWithBody(server, docId, "application/json", bodyReader)
}

// NewAddPermissionRequestWithBody generates requests for AddPermission with any type of body
func NewAddPermissionRequestWithBody(server string, docId DocId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/acl/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePermissionRequest generates requests for DeletePermission
func NewDeletePermissionRequest(server string, docId DocId, permissionId PermissionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionId", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/acl/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListControlsRequest generates requests for ListControls
func NewListControlsRequest(server string, docId DocId, params *ListControlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/controls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetControlRequest generates requests for GetControl
func NewGetControlRequest(server string, docId DocId, controlIdOrName ControlIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controlIdOrName", runtime.ParamLocationPath, controlIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/controls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFormulasRequest generates requests for ListFormulas
func NewListFormulasRequest(server string, docId DocId, params *ListFormulasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/formulas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFormulaRequest generates requests for GetFormula
func NewGetFormulaRequest(server string, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "formulaIdOrName", runtime.ParamLocationPath, formulaIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/formulas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPagesRequest generates requests for ListPages
func NewListPagesRequest(server string, docId DocId, params *ListPagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/pages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageRequest generates requests for GetPage
func NewGetPageRequest(server string, docId DocId, pageIdOrName PageIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pageIdOrName", runtime.ParamLocationPath, pageIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/pages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePageRequest calls the generic UpdatePage builder with application/json body
func NewUpdatePageRequest(server string, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePageRequestWithBody(server, docId, pageIdOrName, "application/json", bodyReader)
}

// NewUpdatePageRequestWithBody generates requests for UpdatePage with any type of body
func NewUpdatePageRequestWithBody(server string, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pageIdOrName", runtime.ParamLocationPath, pageIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/pages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnpublishDocRequest generates requests for UnpublishDoc
func NewUnpublishDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/publish", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishDocRequest calls the generic PublishDoc builder with application/json body
func NewPublishDocRequest(server string, docId DocId, body PublishDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishDocRequestWithBody(server, docId, "application/json", bodyReader)
}

// NewPublishDocRequestWithBody generates requests for PublishDoc with any type of body
func NewPublishDocRequestWithBody(server string, docId DocId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/publish", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, docId DocId, params *ListTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TableTypes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tableTypes", runtime.ParamLocationQuery, *params.TableTypes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *GetTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UseUpdatedTableLayouts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useUpdatedTableLayouts", runtime.ParamLocationQuery, *params.UseUpdatedTableLayouts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListColumnsRequest generates requests for ListColumns
func NewListColumnsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/columns", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibleOnly", runtime.ParamLocationQuery, *params.VisibleOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnRequest generates requests for GetColumn
func NewGetColumnRequest(server string, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "columnIdOrName", runtime.ParamLocationPath, columnIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/columns/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRowsRequest calls the generic DeleteRows builder with application/json body
func NewDeleteRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRowsRequestWithBody(server, docId, tableIdOrName, "application/json", bodyReader)
}

// NewDeleteRowsRequestWithBody generates requests for DeleteRows with any type of body
func NewDeleteRowsRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRowsRequest generates requests for ListRows
func NewListRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UseColumnNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useColumnNames", runtime.ParamLocationQuery, *params.UseColumnNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ValueFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "valueFormat", runtime.ParamLocationQuery, *params.ValueFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibleOnly", runtime.ParamLocationQuery, *params.VisibleOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SyncToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "syncToken", runtime.ParamLocationQuery, *params.SyncToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertRowsRequest calls the generic UpsertRows builder with application/json body
func NewUpsertRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertRowsRequestWithBody(server, docId, tableIdOrName, params, "application/json", bodyReader)
}

// NewUpsertRowsRequestWithBody generates requests for UpsertRows with any type of body
func NewUpsertRowsRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DisableParsing != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disableParsing", runtime.ParamLocationQuery, *params.DisableParsing); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRowRequest generates requests for DeleteRow
func NewDeleteRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rowIdOrName", runtime.ParamLocationPath, rowIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRowRequest generates requests for GetRow
func NewGetRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rowIdOrName", runtime.ParamLocationPath, rowIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UseColumnNames != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useColumnNames", runtime.ParamLocationQuery, *params.UseColumnNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ValueFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "valueFormat", runtime.ParamLocationQuery, *params.ValueFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRowRequest calls the generic UpdateRow builder with application/json body
func NewUpdateRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRowRequestWithBody(server, docId, tableIdOrName, rowIdOrName, params, "application/json", bodyReader)
}

// NewUpdateRowRequestWithBody generates requests for UpdateRow with any type of body
func NewUpdateRowRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rowIdOrName", runtime.ParamLocationPath, rowIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DisableParsing != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disableParsing", runtime.ParamLocationQuery, *params.DisableParsing); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPushButtonRequest generates requests for PushButton
func NewPushButtonRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "docId", runtime.ParamLocationPath, docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tableIdOrName", runtime.ParamLocationPath, tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rowIdOrName", runtime.ParamLocationPath, rowIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "columnIdOrName", runtime.ParamLocationPath, columnIdOrName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s/buttons/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMutationStatusRequest generates requests for GetMutationStatus
func NewGetMutationStatusRequest(server string, requestId RequestId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "requestId", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mutationStatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveBrowserLinkRequest generates requests for ResolveBrowserLink
func NewResolveBrowserLinkRequest(server string, params *ResolveBrowserLinkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resolveBrowserLink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DegradeGracefully != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "degradeGracefully", runtime.ParamLocationQuery, *params.DegradeGracefully); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoamiRequest generates requests for Whoami
func NewWhoamiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceRoleActivityRequest generates requests for ListWorkspaceRoleActivity
func NewListWorkspaceRoleActivityRequest(server string, workspaceId WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceMembersRequest generates requests for ListWorkspaceMembers
func NewListWorkspaceMembersRequest(server string, workspaceId WorkspaceId, params *ListWorkspaceMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludedRoles != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "includedRoles", runtime.ParamLocationQuery, *params.IncludedRoles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeUserRoleRequest calls the generic ChangeUserRole builder with application/json body
func NewChangeUserRoleRequest(server string, workspaceId WorkspaceId, body ChangeUserRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeUserRoleRequestWithBody(server, workspaceId, "application/json", bodyReader)
}

// NewChangeUserRoleRequestWithBody generates requests for ChangeUserRole with any type of body
func NewChangeUserRoleRequestWithBody(server string, workspaceId WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/%s/users/role", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListDocAnalytics request
	ListDocAnalyticsWithResponse(ctx context.Context, params *ListDocAnalyticsParams, reqEditors ...RequestEditorFn) (*ListDocAnalyticsResponse, error)

	// ListCategories request
	ListCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCategoriesResponse, error)

	// ListDocs request
	ListDocsWithResponse(ctx context.Context, params *ListDocsParams, reqEditors ...RequestEditorFn) (*ListDocsResponse, error)

	// CreateDoc request with any body
	CreateDocWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocResponse, error)

	CreateDocWithResponse(ctx context.Context, body CreateDocJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocResponse, error)

	// DeleteDoc request
	DeleteDocWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*DeleteDocResponse, error)

	// GetDoc request
	GetDocWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*GetDocResponse, error)

	// GetSharingMetadata request
	GetSharingMetadataWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*GetSharingMetadataResponse, error)

	// GetPermissions request
	GetPermissionsWithResponse(ctx context.Context, docId DocId, params *GetPermissionsParams, reqEditors ...RequestEditorFn) (*GetPermissionsResponse, error)

	// AddPermission request with any body
	AddPermissionWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPermissionResponse, error)

	AddPermissionWithResponse(ctx context.Context, docId DocId, body AddPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPermissionResponse, error)

	// DeletePermission request
	DeletePermissionWithResponse(ctx context.Context, docId DocId, permissionId PermissionId, reqEditors ...RequestEditorFn) (*DeletePermissionResponse, error)

	// ListControls request
	ListControlsWithResponse(ctx context.Context, docId DocId, params *ListControlsParams, reqEditors ...RequestEditorFn) (*ListControlsResponse, error)

	// GetControl request
	GetControlWithResponse(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName, reqEditors ...RequestEditorFn) (*GetControlResponse, error)

	// ListFormulas request
	ListFormulasWithResponse(ctx context.Context, docId DocId, params *ListFormulasParams, reqEditors ...RequestEditorFn) (*ListFormulasResponse, error)

	// GetFormula request
	GetFormulaWithResponse(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName, reqEditors ...RequestEditorFn) (*GetFormulaResponse, error)

	// ListPages request
	ListPagesWithResponse(ctx context.Context, docId DocId, params *ListPagesParams, reqEditors ...RequestEditorFn) (*ListPagesResponse, error)

	// GetPage request
	GetPageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, reqEditors ...RequestEditorFn) (*GetPageResponse, error)

	// UpdatePage request with any body
	UpdatePageWithBodyWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error)

	UpdatePageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error)

	// UnpublishDoc request
	UnpublishDocWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*UnpublishDocResponse, error)

	// PublishDoc request with any body
	PublishDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishDocResponse, error)

	PublishDocWithResponse(ctx context.Context, docId DocId, body PublishDocJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishDocResponse, error)

	// ListTables request
	ListTablesWithResponse(ctx context.Context, docId DocId, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error)

	// GetTable request
	GetTableWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// ListColumns request
	ListColumnsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams, reqEditors ...RequestEditorFn) (*ListColumnsResponse, error)

	// GetColumn request
	GetColumnWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*GetColumnResponse, error)

	// DeleteRows request with any body
	DeleteRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRowsResponse, error)

	DeleteRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRowsResponse, error)

	// ListRows request
	ListRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams, reqEditors ...RequestEditorFn) (*ListRowsResponse, error)

	// UpsertRows request with any body
	UpsertRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertRowsResponse, error)

	UpsertRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertRowsResponse, error)

	// DeleteRow request
	DeleteRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, reqEditors ...RequestEditorFn) (*DeleteRowResponse, error)

	// GetRow request
	GetRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams, reqEditors ...RequestEditorFn) (*GetRowResponse, error)

	// UpdateRow request with any body
	UpdateRowWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRowResponse, error)

	UpdateRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRowResponse, error)

	// PushButton request
	PushButtonWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*PushButtonResponse, error)

	// GetMutationStatus request
	GetMutationStatusWithResponse(ctx context.Context, requestId RequestId, reqEditors ...RequestEditorFn) (*GetMutationStatusResponse, error)

	// ResolveBrowserLink request
	ResolveBrowserLinkWithResponse(ctx context.Context, params *ResolveBrowserLinkParams, reqEditors ...RequestEditorFn) (*ResolveBrowserLinkResponse, error)

	// Whoami request
	WhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WhoamiResponse, error)

	// ListWorkspaceRoleActivity request
	ListWorkspaceRoleActivityWithResponse(ctx context.Context, workspaceId WorkspaceId, reqEditors ...RequestEditorFn) (*ListWorkspaceRoleActivityResponse, error)

	// ListWorkspaceMembers request
	ListWorkspaceMembersWithResponse(ctx context.Context, workspaceId WorkspaceId, params *ListWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*ListWorkspaceMembersResponse, error)

	// ChangeUserRole request with any body
	ChangeUserRoleWithBodyWithResponse(ctx context.Context, workspaceId WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeUserRoleResponse, error)

	ChangeUserRoleWithResponse(ctx context.Context, workspaceId WorkspaceId, body ChangeUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeUserRoleResponse, error)
}

type ListDocAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocAnalyticsCollection
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocCategoryList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DocumentCreationResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DocDelete
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Doc
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSharingMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclMetadata
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSharingMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSharingMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddPermissionResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePermissionResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListControlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControlList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListControlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListControlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Control
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFormulasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FormulaList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFormulasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFormulasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFormulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Formula
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFormulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFormulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON410 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PageUpdateResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpublishDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnpublishResult
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UnpublishDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpublishDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PublishResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r PublishDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnDetail
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowsDeleteResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowList
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowsUpsertResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpsertRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowDeleteResult
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowDetail
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowUpdateResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushButtonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PushButtonResult
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r PushButtonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushButtonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMutationStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MutationStatus
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMutationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMutationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveBrowserLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiLink
	JSON400      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ResolveBrowserLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveBrowserLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r WhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceRoleActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWorkspaceRoleActivity
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceRoleActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceRoleActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceMembersList
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeUserRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChangeRoleResult
	JSON401      *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {
		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ChangeUserRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeUserRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListDocAnalyticsWithResponse request returning *ListDocAnalyticsResponse
func (c *ClientWithResponses) ListDocAnalyticsWithResponse(ctx context.Context, params *ListDocAnalyticsParams, reqEditors ...RequestEditorFn) (*ListDocAnalyticsResponse, error) {
	rsp, err := c.ListDocAnalytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDocAnalyticsResponse(rsp)
}

// ListCategoriesWithResponse request returning *ListCategoriesResponse
func (c *ClientWithResponses) ListCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCategoriesResponse, error) {
	rsp, err := c.ListCategories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCategoriesResponse(rsp)
}

// ListDocsWithResponse request returning *ListDocsResponse
func (c *ClientWithResponses) ListDocsWithResponse(ctx context.Context, params *ListDocsParams, reqEditors ...RequestEditorFn) (*ListDocsResponse, error) {
	rsp, err := c.ListDocs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDocsResponse(rsp)
}

// CreateDocWithBodyWithResponse request with arbitrary body returning *CreateDocResponse
func (c *ClientWithResponses) CreateDocWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocResponse, error) {
	rsp, err := c.CreateDocWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocResponse(rsp)
}

func (c *ClientWithResponses) CreateDocWithResponse(ctx context.Context, body CreateDocJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocResponse, error) {
	rsp, err := c.CreateDoc(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocResponse(rsp)
}

// DeleteDocWithResponse request returning *DeleteDocResponse
func (c *ClientWithResponses) DeleteDocWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*DeleteDocResponse, error) {
	rsp, err := c.DeleteDoc(ctx, docId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDocResponse(rsp)
}

// GetDocWithResponse request returning *GetDocResponse
func (c *ClientWithResponses) GetDocWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*GetDocResponse, error) {
	rsp, err := c.GetDoc(ctx, docId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDocResponse(rsp)
}

// GetSharingMetadataWithResponse request returning *GetSharingMetadataResponse
func (c *ClientWithResponses) GetSharingMetadataWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*GetSharingMetadataResponse, error) {
	rsp, err := c.GetSharingMetadata(ctx, docId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSharingMetadataResponse(rsp)
}

// GetPermissionsWithResponse request returning *GetPermissionsResponse
func (c *ClientWithResponses) GetPermissionsWithResponse(ctx context.Context, docId DocId, params *GetPermissionsParams, reqEditors ...RequestEditorFn) (*GetPermissionsResponse, error) {
	rsp, err := c.GetPermissions(ctx, docId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsResponse(rsp)
}

// AddPermissionWithBodyWithResponse request with arbitrary body returning *AddPermissionResponse
func (c *ClientWithResponses) AddPermissionWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPermissionResponse, error) {
	rsp, err := c.AddPermissionWithBody(ctx, docId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPermissionResponse(rsp)
}

func (c *ClientWithResponses) AddPermissionWithResponse(ctx context.Context, docId DocId, body AddPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPermissionResponse, error) {
	rsp, err := c.AddPermission(ctx, docId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPermissionResponse(rsp)
}

// DeletePermissionWithResponse request returning *DeletePermissionResponse
func (c *ClientWithResponses) DeletePermissionWithResponse(ctx context.Context, docId DocId, permissionId PermissionId, reqEditors ...RequestEditorFn) (*DeletePermissionResponse, error) {
	rsp, err := c.DeletePermission(ctx, docId, permissionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePermissionResponse(rsp)
}

// ListControlsWithResponse request returning *ListControlsResponse
func (c *ClientWithResponses) ListControlsWithResponse(ctx context.Context, docId DocId, params *ListControlsParams, reqEditors ...RequestEditorFn) (*ListControlsResponse, error) {
	rsp, err := c.ListControls(ctx, docId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListControlsResponse(rsp)
}

// GetControlWithResponse request returning *GetControlResponse
func (c *ClientWithResponses) GetControlWithResponse(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName, reqEditors ...RequestEditorFn) (*GetControlResponse, error) {
	rsp, err := c.GetControl(ctx, docId, controlIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetControlResponse(rsp)
}

// ListFormulasWithResponse request returning *ListFormulasResponse
func (c *ClientWithResponses) ListFormulasWithResponse(ctx context.Context, docId DocId, params *ListFormulasParams, reqEditors ...RequestEditorFn) (*ListFormulasResponse, error) {
	rsp, err := c.ListFormulas(ctx, docId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFormulasResponse(rsp)
}

// GetFormulaWithResponse request returning *GetFormulaResponse
func (c *ClientWithResponses) GetFormulaWithResponse(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName, reqEditors ...RequestEditorFn) (*GetFormulaResponse, error) {
	rsp, err := c.GetFormula(ctx, docId, formulaIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFormulaResponse(rsp)
}

// ListPagesWithResponse request returning *ListPagesResponse
func (c *ClientWithResponses) ListPagesWithResponse(ctx context.Context, docId DocId, params *ListPagesParams, reqEditors ...RequestEditorFn) (*ListPagesResponse, error) {
	rsp, err := c.ListPages(ctx, docId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPagesResponse(rsp)
}

// GetPageWithResponse request returning *GetPageResponse
func (c *ClientWithResponses) GetPageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, reqEditors ...RequestEditorFn) (*GetPageResponse, error) {
	rsp, err := c.GetPage(ctx, docId, pageIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageResponse(rsp)
}

// UpdatePageWithBodyWithResponse request with arbitrary body returning *UpdatePageResponse
func (c *ClientWithResponses) UpdatePageWithBodyWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePageWithBody(ctx, docId, pageIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

func (c *ClientWithResponses) UpdatePageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePage(ctx, docId, pageIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

// UnpublishDocWithResponse request returning *UnpublishDocResponse
func (c *ClientWithResponses) UnpublishDocWithResponse(ctx context.Context, docId DocId, reqEditors ...RequestEditorFn) (*UnpublishDocResponse, error) {
	rsp, err := c.UnpublishDoc(ctx, docId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpublishDocResponse(rsp)
}

// PublishDocWithBodyWithResponse request with arbitrary body returning *PublishDocResponse
func (c *ClientWithResponses) PublishDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishDocResponse, error) {
	rsp, err := c.PublishDocWithBody(ctx, docId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishDocResponse(rsp)
}

func (c *ClientWithResponses) PublishDocWithResponse(ctx context.Context, docId DocId, body PublishDocJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishDocResponse, error) {
	rsp, err := c.PublishDoc(ctx, docId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishDocResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, docId DocId, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, docId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, docId, tableIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ListColumnsWithResponse request returning *ListColumnsResponse
func (c *ClientWithResponses) ListColumnsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams, reqEditors ...RequestEditorFn) (*ListColumnsResponse, error) {
	rsp, err := c.ListColumns(ctx, docId, tableIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListColumnsResponse(rsp)
}

// GetColumnWithResponse request returning *GetColumnResponse
func (c *ClientWithResponses) GetColumnWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*GetColumnResponse, error) {
	rsp, err := c.GetColumn(ctx, docId, tableIdOrName, columnIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnResponse(rsp)
}

// DeleteRowsWithBodyWithResponse request with arbitrary body returning *DeleteRowsResponse
func (c *ClientWithResponses) DeleteRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRowsWithBody(ctx, docId, tableIdOrName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

func (c *ClientWithResponses) DeleteRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRows(ctx, docId, tableIdOrName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

// ListRowsWithResponse request returning *ListRowsResponse
func (c *ClientWithResponses) ListRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams, reqEditors ...RequestEditorFn) (*ListRowsResponse, error) {
	rsp, err := c.ListRows(ctx, docId, tableIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRowsResponse(rsp)
}

// UpsertRowsWithBodyWithResponse request with arbitrary body returning *UpsertRowsResponse
func (c *ClientWithResponses) UpsertRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertRowsResponse, error) {
	rsp, err := c.UpsertRowsWithBody(ctx, docId, tableIdOrName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRowsResponse(rsp)
}

func (c *ClientWithResponses) UpsertRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertRowsResponse, error) {
	rsp, err := c.UpsertRows(ctx, docId, tableIdOrName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRowsResponse(rsp)
}

// DeleteRowWithResponse request returning *DeleteRowResponse
func (c *ClientWithResponses) DeleteRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, reqEditors ...RequestEditorFn) (*DeleteRowResponse, error) {
	rsp, err := c.DeleteRow(ctx, docId, tableIdOrName, rowIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowResponse(rsp)
}

// GetRowWithResponse request returning *GetRowResponse
func (c *ClientWithResponses) GetRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams, reqEditors ...RequestEditorFn) (*GetRowResponse, error) {
	rsp, err := c.GetRow(ctx, docId, tableIdOrName, rowIdOrName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRowResponse(rsp)
}

// UpdateRowWithBodyWithResponse request with arbitrary body returning *UpdateRowResponse
func (c *ClientWithResponses) UpdateRowWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRowResponse, error) {
	rsp, err := c.UpdateRowWithBody(ctx, docId, tableIdOrName, rowIdOrName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRowResponse, error) {
	rsp, err := c.UpdateRow(ctx, docId, tableIdOrName, rowIdOrName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowResponse(rsp)
}

// PushButtonWithResponse request returning *PushButtonResponse
func (c *ClientWithResponses) PushButtonWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName, reqEditors ...RequestEditorFn) (*PushButtonResponse, error) {
	rsp, err := c.PushButton(ctx, docId, tableIdOrName, rowIdOrName, columnIdOrName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushButtonResponse(rsp)
}

// GetMutationStatusWithResponse request returning *GetMutationStatusResponse
func (c *ClientWithResponses) GetMutationStatusWithResponse(ctx context.Context, requestId RequestId, reqEditors ...RequestEditorFn) (*GetMutationStatusResponse, error) {
	rsp, err := c.GetMutationStatus(ctx, requestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMutationStatusResponse(rsp)
}

// ResolveBrowserLinkWithResponse request returning *ResolveBrowserLinkResponse
func (c *ClientWithResponses) ResolveBrowserLinkWithResponse(ctx context.Context, params *ResolveBrowserLinkParams, reqEditors ...RequestEditorFn) (*ResolveBrowserLinkResponse, error) {
	rsp, err := c.ResolveBrowserLink(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveBrowserLinkResponse(rsp)
}

// WhoamiWithResponse request returning *WhoamiResponse
func (c *ClientWithResponses) WhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WhoamiResponse, error) {
	rsp, err := c.Whoami(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoamiResponse(rsp)
}

// ListWorkspaceRoleActivityWithResponse request returning *ListWorkspaceRoleActivityResponse
func (c *ClientWithResponses) ListWorkspaceRoleActivityWithResponse(ctx context.Context, workspaceId WorkspaceId, reqEditors ...RequestEditorFn) (*ListWorkspaceRoleActivityResponse, error) {
	rsp, err := c.ListWorkspaceRoleActivity(ctx, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceRoleActivityResponse(rsp)
}

// ListWorkspaceMembersWithResponse request returning *ListWorkspaceMembersResponse
func (c *ClientWithResponses) ListWorkspaceMembersWithResponse(ctx context.Context, workspaceId WorkspaceId, params *ListWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*ListWorkspaceMembersResponse, error) {
	rsp, err := c.ListWorkspaceMembers(ctx, workspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceMembersResponse(rsp)
}

// ChangeUserRoleWithBodyWithResponse request with arbitrary body returning *ChangeUserRoleResponse
func (c *ClientWithResponses) ChangeUserRoleWithBodyWithResponse(ctx context.Context, workspaceId WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeUserRoleResponse, error) {
	rsp, err := c.ChangeUserRoleWithBody(ctx, workspaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeUserRoleResponse(rsp)
}

func (c *ClientWithResponses) ChangeUserRoleWithResponse(ctx context.Context, workspaceId WorkspaceId, body ChangeUserRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeUserRoleResponse, error) {
	rsp, err := c.ChangeUserRole(ctx, workspaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeUserRoleResponse(rsp)
}

// ParseListDocAnalyticsResponse parses an HTTP response from a ListDocAnalyticsWithResponse call
func ParseListDocAnalyticsResponse(rsp *http.Response) (*ListDocAnalyticsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDocAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocAnalyticsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListCategoriesResponse parses an HTTP response from a ListCategoriesWithResponse call
func ParseListCategoriesResponse(rsp *http.Response) (*ListCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocCategoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListDocsResponse parses an HTTP response from a ListDocsWithResponse call
func ParseListDocsResponse(rsp *http.Response) (*ListDocsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateDocResponse parses an HTTP response from a CreateDocWithResponse call
func ParseCreateDocResponse(rsp *http.Response) (*CreateDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentCreationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteDocResponse parses an HTTP response from a DeleteDocWithResponse call
func ParseDeleteDocResponse(rsp *http.Response) (*DeleteDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DocDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetDocResponse parses an HTTP response from a GetDocWithResponse call
func ParseGetDocResponse(rsp *http.Response) (*GetDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Doc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetSharingMetadataResponse parses an HTTP response from a GetSharingMetadataWithResponse call
func ParseGetSharingMetadataResponse(rsp *http.Response) (*GetSharingMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSharingMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPermissionsResponse parses an HTTP response from a GetPermissionsWithResponse call
func ParseGetPermissionsResponse(rsp *http.Response) (*GetPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseAddPermissionResponse parses an HTTP response from a AddPermissionWithResponse call
func ParseAddPermissionResponse(rsp *http.Response) (*AddPermissionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddPermissionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeletePermissionResponse parses an HTTP response from a DeletePermissionWithResponse call
func ParseDeletePermissionResponse(rsp *http.Response) (*DeletePermissionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePermissionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListControlsResponse parses an HTTP response from a ListControlsWithResponse call
func ParseListControlsResponse(rsp *http.Response) (*ListControlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListControlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetControlResponse parses an HTTP response from a GetControlWithResponse call
func ParseGetControlResponse(rsp *http.Response) (*GetControlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Control
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListFormulasResponse parses an HTTP response from a ListFormulasWithResponse call
func ParseListFormulasResponse(rsp *http.Response) (*ListFormulasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFormulasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormulaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetFormulaResponse parses an HTTP response from a GetFormulaWithResponse call
func ParseGetFormulaResponse(rsp *http.Response) (*GetFormulaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFormulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Formula
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListPagesResponse parses an HTTP response from a ListPagesWithResponse call
func ParseListPagesResponse(rsp *http.Response) (*ListPagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPageResponse parses an HTTP response from a GetPageWithResponse call
func ParseGetPageResponse(rsp *http.Response) (*GetPageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdatePageResponse parses an HTTP response from a UpdatePageWithResponse call
func ParseUpdatePageResponse(rsp *http.Response) (*UpdatePageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PageUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUnpublishDocResponse parses an HTTP response from a UnpublishDocWithResponse call
func ParseUnpublishDocResponse(rsp *http.Response) (*UnpublishDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpublishDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnpublishResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePublishDocResponse parses an HTTP response from a PublishDocWithResponse call
func ParsePublishDocResponse(rsp *http.Response) (*PublishDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PublishResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListColumnsResponse parses an HTTP response from a ListColumnsWithResponse call
func ParseListColumnsResponse(rsp *http.Response) (*ListColumnsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetColumnResponse parses an HTTP response from a GetColumnWithResponse call
func ParseGetColumnResponse(rsp *http.Response) (*GetColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRowsResponse parses an HTTP response from a DeleteRowsWithResponse call
func ParseDeleteRowsResponse(rsp *http.Response) (*DeleteRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowsDeleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListRowsResponse parses an HTTP response from a ListRowsWithResponse call
func ParseListRowsResponse(rsp *http.Response) (*ListRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpsertRowsResponse parses an HTTP response from a UpsertRowsWithResponse call
func ParseUpsertRowsResponse(rsp *http.Response) (*UpsertRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowsUpsertResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRowResponse parses an HTTP response from a DeleteRowWithResponse call
func ParseDeleteRowResponse(rsp *http.Response) (*DeleteRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowDeleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetRowResponse parses an HTTP response from a GetRowWithResponse call
func ParseGetRowResponse(rsp *http.Response) (*GetRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdateRowResponse parses an HTTP response from a UpdateRowWithResponse call
func ParseUpdateRowResponse(rsp *http.Response) (*UpdateRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePushButtonResponse parses an HTTP response from a PushButtonWithResponse call
func ParsePushButtonResponse(rsp *http.Response) (*PushButtonResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PushButtonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PushButtonResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMutationStatusResponse parses an HTTP response from a GetMutationStatusWithResponse call
func ParseGetMutationStatusResponse(rsp *http.Response) (*GetMutationStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMutationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MutationStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseResolveBrowserLinkResponse parses an HTTP response from a ResolveBrowserLinkWithResponse call
func ParseResolveBrowserLinkResponse(rsp *http.Response) (*ResolveBrowserLinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveBrowserLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWhoamiResponse parses an HTTP response from a WhoamiWithResponse call
func ParseWhoamiResponse(rsp *http.Response) (*WhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListWorkspaceRoleActivityResponse parses an HTTP response from a ListWorkspaceRoleActivityWithResponse call
func ParseListWorkspaceRoleActivityResponse(rsp *http.Response) (*ListWorkspaceRoleActivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceRoleActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWorkspaceRoleActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListWorkspaceMembersResponse parses an HTTP response from a ListWorkspaceMembersWithResponse call
func ParseListWorkspaceMembersResponse(rsp *http.Response) (*ListWorkspaceMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceMembersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseChangeUserRoleResponse parses an HTTP response from a ChangeUserRoleWithResponse call
func ParseChangeUserRoleResponse(rsp *http.Response) (*ChangeUserRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeUserRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChangeRoleResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}
